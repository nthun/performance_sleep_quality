---
title: "Sleep quality and cognitve performance analysis"
author: "Tamas Nagy"
date: "January 21, 2019"
bibliography: "refs/refs.bib" 
output: 
  html_document:
   toc: true
   toc_float: true
editor_options: 
  chunk_output_type: console
---

# Aim
We want to investigate the effect of poor sleep quality on cognitive performance. 
Two sleep quality questionnaires and several cognitive tests were administered across 
three studies.  

First, we want to aggregate the sleep quality questionnaires into one 
sleep quality metric. Then we want to investigate the association while controlling for 
the potential effect of the separate studies. Subsequently, we want to obtain 
Bayes Factors, so we can draw conclusions about the probability of null or alternative 
hypothesis.


```{r setup, include=FALSE}
# install.packages(c("tidyverse", "janitor","psych","lme4", "cowplot", "MASS"))

library(MASS)
library(tidyverse)
library(lme4)
library(robustlmm)
library(cowplot)
library(broom.mixed)

# Define variable labels. This is important for making the plots pretty
variables_needed <- 
  c(
    "RT Triplet learning" = "trip_learn_all_rt",
    "ACC Triplet learning" = "trip_learn_all_acc",                 
    "ACC Higher-order sequence learning" = "highrer_order_acc",
    "RT Higher-order sequence learning" = "highrer_order_rt",
    "ACC Statistical learning" = "stat_learn_acc",
    "RT Statistical learning" = "stat_learn_rt",
    "Average ACC" = "acc_avg",
    "ACC general skill learning" = "acc_gs",
    "RT average" = "rt_avg",
    "RT general skill learning" = "rt_gs_1_min_4",
    "Counting Span" = "cs_avg",
    "WCST – perseverative error" = "wcst_pers_error",
    "Sleep disturbance" = "sleep_disturb",
    "Groningen Sleep Quality Scale" = "groningen_ossz",
    "Athens Insomnia Scale" = "ais_ossz",
    "Sleep diary" = "diary_psqi_4_f",
    "Pittsburgh Sleep Quality Index" = "psqi_osszpont",
    "study"
  )

sleep_variables <- c("groningen_ossz", "ais_ossz", "diary_psqi_4_f", "psqi_osszpont")

variable_groups <- 
  tribble(~outcome_var, ~group,
          "RT Triplet learning", "RT learning indices",
          "ACC Triplet learning", "ACC learning indices",                 
          "ACC Higher-order sequence learning", "ACC learning indices",
          "RT Higher-order sequence learning", "RT learning indices",
          "ACC Statistical learning", "ACC learning indices",
          "RT Statistical learning", "RT learning indices",
          "Average ACC", "General skill indices",
          "ACC general skill learning", "General skill indices",
          "RT average", "General skill indices",
          "RT general skill learning", "General skill indices",
          "Counting Span", "WM and EF indices",
          "WCST – perseverative error", "WM and EF indices"
  )

  variables_recode <-
    names(variables_needed) %>% 
    set_names(variables_needed)

```

```{r data_read, message=FALSE, warning=FALSE}
df_raw <- read_csv2("data/PSQIcikkhez adatok.csv", 
                    locale = locale(encoding = "WINDOWS-1252"))

# Process data for ease of use
# Clean variable names: Remove spaces, accented characters, capitals, make smallcase
# Translate Hungarian variable names, recode sex

df <-
  df_raw %>% 
  set_names(snakecase::to_any_case(names(.), 
                                   transliterations = "Latin-ASCII")) %>% 
  rename(sex = nem, age = eletkor, education_yrs = iskolazottsag) %>% 
  mutate(sex = recode(sex, `1` = "Male", `2` = "Female", `0` = "Not specified"))
```

# Principal component analysis of sleep quality

We conduct a principal component analysis (PCA) to aggregate the two sleep quality 
measures into one. 

```{r}
sleepd_pca <- 
  df %>% 
  select(ais_ossz, psqi_osszpont) %>% 
  psych::pca(nfactors = 1)

# Show PCA result
sleepd_pca

bartlett_result <- 
  df %>% 
  select(ais_ossz, psqi_osszpont) %>% 
  cor() %>% 
  psych::cortest.bartlett(n = 235)

# Add the PC to the original data 
df <- 
  df %>% 
  mutate(sleep_disturb = sleepd_pca$scores[,1])
```

The Bartlett's test of shericity indicated that the correlation between the scales were
adequately large for a PCA, $\chi^2(235)$ = `r round(bartlett_result$chisq, 2)`, p < .0001.

One principal factor with an eigenvalue of `r round(sleepd_pca$values[1], 2)` was extracted to represent 
sleep disturbance. The component explained `r scales::percent(sleepd_pca$fit.off)` of the 
variance, and it was named sleep disturbance. 

# Distribution of sleep quality questionnaires (original and the one derived from PCA)

```{r}
df %>% 
  select(one_of(sleep_variables), sleep_disturb) %>% 
  gather(measure, value) %>% 
  mutate(measure = recode(measure, !!!variables_recode)) %>% 
  ggplot() +
  aes(x = value) +
  geom_histogram() +
  facet_wrap(~measure, scales = "free_x") +
  theme_light()
```


# Exploraton of important variables
```{r}
skimr::skim_with(numeric = list(hist = NULL)) # Remove spark histograms

df %>% 
  select(one_of(variables_needed)) %>% 
  skimr::skim()
```

# Checking hypotheses
First, we create several linear mixed-effects models (LMEM) with the same predictor (sleep disturbance), and the cognitive performance metrics as outcomes. The LMEM contains a 
random intercept term by study to account for the potential differences between studies.

After we ran the models, the residuals did not show normal distribution. Therefore we 
reran the analysis using a roboust estimation that does not assume normality of residuals 
@Koller2016.

```{r warning=FALSE}
all_models <- 
  df %>% 
  select(one_of(variables_needed), -one_of(sleep_variables)) %>% 
  gather(outcome_var, value, -sleep_disturb, -study) %>% 
  drop_na(sleep_disturb, value) %>% 
  split(.$outcome_var) %>% 
  map(., ~rlmer(scale(value) ~ scale(sleep_disturb) + (1|study), REML = FALSE,
               data = .x))

# From the models, we can get the  standardized betas for the slopes and p the values
# We recalculate the models using restricted likelihood for this, so the estimated parameters will be more accurate

models <- 
  all_models %>% 
  map(~update(.x, REML = TRUE)) %>% 
  map(~tidy(.)) %>% 
  bind_rows(.id = "outcome_var") %>% 
  filter(term == "scale(sleep_disturb)") %>% 
  # Add number of observations by hand and calculate the two-sided p statistic 
  # based on t value and residual df
  mutate(
         df = c(rep(230, 11), 224),
         p = 2*pt(q = -abs(statistic), df = df))

models %>% 
  mutate(outcome_var = recode(outcome_var, !!!variables_recode)) %>% 
  select(-group, -effect, -term) %>% 
  left_join(variable_groups, by = "outcome_var") %>% 
  arrange(group) %>% 
  select(group, outcome_var, everything()) %>% 
  knitr::kable(digits = 4)
```

The LMEMs show no evidence that cognitive performance metrics were affected by poor sleep quality.

# Calculate Bayes Factors ($BF_{01}$)

In order to make prediction about the likelihood of the null hypothesis - as compared to
the alternative hypothesis - we calculated the Bayes Factor [@Wagenmakers2007].
To calculate the BIC derived Bayes Factor, we calculated the Bayesian Information Criterion (BIC) for null models that only included a fixed intercept, and a random intercept term by study. Maximum Likelihood estimation was used so the models could be compared. The $BF_{01}$ were calculated based on @Wagenmakers2007. 

```{r}
# BF was calculated based on this tutorial: https://rpubs.com/lindeloev/bayes_factors
# Calculate BIC for NULL models
null_BIC <-
  df %>%
  select(one_of(variables_needed), -one_of(sleep_variables)) %>% 
  gather(outcome_var, value, -sleep_disturb, -study) %>% 
  split(.$outcome_var) %>%
  map_df(., ~lmer(scale(value) ~ 1 + (1|study), 
                  REML = FALSE, 
                  data = .x) %>% 
             glance(.) %>% 
             select(nullBIC = BIC), .id = "outcome_var") 

# Calculate BF01 for all models
df %>% 
  select(one_of(variables_needed), -one_of(sleep_variables)) %>% 
  gather(outcome_var, value, -sleep_disturb, -study) %>% 
  split(.$outcome_var) %>% 
  map(., ~lmer(scale(value) ~ scale(sleep_disturb) + (1|study), REML = FALSE,
               data = .x)) %>% 
  map_df(~broom::glance(.),
         .id = "outcome_var") %>%
  left_join(null_BIC, by = "outcome_var") %>%
  mutate(BF01 = exp((BIC - nullBIC)/2)) %>% 
  select(outcome_var, BF01) %>% 
  mutate(outcome_var = recode(outcome_var, !!!variables_recode)) %>% 
  left_join(variable_groups, by = "outcome_var") %>% 
  arrange(group) %>% 
  select(group, outcome_var, BF01) %>% 
  knitr::kable(digits = 4)

```

As all BFs were over 3, we can conclude that the cognitive performance of the study
population seems to be unaffected by poor sleep.

# Visualize the association with sleep disturbance for each outcome measure

```{r fig.height=8, fig.width=12}
# Create a plot 
plot_df <-
  df %>%
  # Use pretty variable names
  select(variables_needed) %>% 
  # Put data into long format so the outcome vriable can be faceted
  gather(outcome_var, value, -`Sleep disturbance`, -study) %>% 
  # Add variable group names
  left_join(variable_groups, by = "outcome_var")

# Create a plotting function for all groups separately
plot_single <- function(outcome_name){
  plot_df %>%
    filter(outcome_var == outcome_name) %>% 
    ggplot() +
    aes(x = `Sleep disturbance`, y = value, color = as.factor(study)) +
    geom_point(alpha = .5) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_color_brewer(palette = "Paired") +
    facet_wrap(~outcome_var, scales = "free_y") +
    labs(title = NULL, x = NULL, y = NULL) +
    theme_bw() +
    theme(legend.position = "none",
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank()) +
    cowplot::panel_border()
}

# Put all rows of the plot into a list
single_plots <- 
  map(unique(plot_df$outcome_var), plot_single)

# Create one plot to get the legend
plot_1 <-
  plot_df %>%
  filter(outcome_var == "RT Triplet learning") %>% 
  ggplot() +
  aes(x = `Sleep disturbance`, y = value, color = as.factor(study)) +
  geom_point(alpha = .5) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_color_brewer(palette = "Paired") +
  labs(color = "Study") +
  theme(legend.direction = "horizontal",
        legend.justification = "right",
        legend.box.just = "top", 
        legend.box.margin = margin())

# Get legend
plot_legend <- cowplot::get_legend(plot_1)

# Assemble the plot. 
# I realize that the code is a bit ugly, but the outcome seems acceptable
plot_grid(
  NULL, NULL, plot_legend,
  single_plots[[1]], single_plots[[4]], single_plots[[6]], 
  NULL, NULL, NULL, 
  single_plots[[2]], single_plots[[3]], single_plots[[5]], 
  NULL, NULL, NULL, 
  single_plots[[9]], single_plots[[10]],single_plots[[11]], 
  NULL, NULL, NULL, 
  single_plots[[7]], single_plots[[8]], single_plots[[12]],
  labels = c(
    "", "", "",
    "A) RT learning indices", "", "",
    "", "", "",
    "B) ACC learning indices", "", "", 
    "", "", "",
    "C) General skill indices", "", "D) WM and EF indices",
    "", "", "",
    "", "", ""),
  hjust = -.05,
  vjust = .05,
  nrow = 8,
  rel_heights = c(.20, 1, .15, 1, .15, 1, .15, 1)
) + 
  geom_segment(y = .74, yend = .74, x = .02, xend = .98, size = 1.1) +
  geom_segment(y = .49, yend = .49, x = .02, xend = .98, size = 1.1) +
  geom_segment(y = .02, yend = .49, x = .668, xend = .668, size = 1.1) +
  NULL
```

# Calculating associations between sleep diary answers, GSQI, and the executing functions

We used robust linear regression to model the relationship between sleep diary answers, QSQI score, and the executive functions. We calculated the BF in the previously described way.

```{r}
study2_long <-
  df %>% 
  filter(study == 2) %>%
  select(one_of(variables_needed), -one_of(sleep_variables), -sleep_disturb, -study,
         groningen_ossz, diary_psqi_4_f) %>% 
  gather(outcome_var, out_value, -groningen_ossz, -diary_psqi_4_f, na.rm = TRUE) %>% 
  gather(predictor_var, pred_value, groningen_ossz, diary_psqi_4_f) %>% 
  drop_na(pred_value, out_value) %>% 
  group_nest(outcome_var, predictor_var)

# Get null BICs
study2_nullBIC <-
  study2_long %>% 
  mutate(model = map(data, ~MASS::rlm(scale(out_value) ~ 1,
                                data = .x) %>% 
                           glance(.) %>% 
                           select(nullBIC = BIC))) %>% 
  unnest(model) %>% 
  select(-data)
  
  
study2_models <-
  study2_long %>% 
  mutate(model = map(data, ~MASS::rlm(scale(out_value) ~ scale(pred_value),
                                data = .x)),
         df = map_int(data, ~nrow(.x))-1)

# Show predictors
study2_models %>% 
  mutate(model = map(model, ~tidy(.x))) %>% 
  unnest(model) %>% 
  filter(str_detect(term, "scale")) %>% 
  mutate_at(vars(outcome_var, predictor_var),
            ~recode(., !!!variables_recode)) %>% 
  left_join(variable_groups, ., by = "outcome_var") %>% 
  select(group, everything(), -term) %>% 
  mutate(p = 2*pt(q = -abs(statistic), df = df)) %>% 
  arrange(predictor_var, group, outcome_var) %>% 
  knitr::kable(digits = 4)

```

```{r}
# Calculate BF
study2_models %>% 
  mutate(model = map(model, ~glance(.x))) %>% 
  unnest(model) %>% 
  left_join(study2_nullBIC, by = c("outcome_var", "predictor_var")) %>% 
  mutate(BF01 = exp((BIC - nullBIC)/2) %>% round(4)) %>% 
  mutate_at(vars(outcome_var, predictor_var),
            ~recode(., !!!variables_recode)) %>% 
  left_join(variable_groups, ., by = "outcome_var") %>% 
  select(group, outcome_var, predictor_var, BF01) %>%
  arrange(predictor_var, group, outcome_var) %>% 
  knitr::kable(digits = 4)
```


```{r fig.height=8, fig.width=12}
plot2_df <-
  study2_long %>% 
  mutate_at(vars(outcome_var, predictor_var),
            ~recode(., !!!variables_recode)) %>% 
  unnest()

# Create a plotting function for all groups separately
plot_double <- function(outcome_name){
  plot2_df %>%
    filter(outcome_var == outcome_name) %>% 
    mutate_at(vars(outcome_var, predictor_var),
              ~recode(., !!!variables_recode)) %>% 
    ggplot() +
    aes(x = pred_value, y = out_value, color = predictor_var) +
    geom_point(alpha = .5) +
    geom_smooth(method = "lm", se = FALSE) +
    facet_wrap(~outcome_var, scales = "free_y") +
    labs(title = NULL, x = NULL, y = NULL) +
    theme_bw() +
    theme(legend.position = "none",
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank()) +
    cowplot::panel_border()
}

# Put all rows of the plot into a list
double_plots <-
  plot2_df %>%
  group_nest(outcome_var, keep = TRUE) %>% 
  mutate(plot = map(data, ~plot_double(.x$outcome_var))) %>% 
  pull(plot)

# Create one plot to get the legend
plot_2 <-
  plot2_df %>%
  filter(outcome_var == "RT Triplet learning") %>% 
  ggplot() +
  aes(x = pred_value, y = out_value, color = predictor_var) +
  geom_point(alpha = .5) +
  geom_smooth(method = "lm", se = FALSE) +
  # scale_color_viridis_d() +
  labs(color = "Predictor") +
  theme(legend.direction = "horizontal",
        legend.justification = "right",
        legend.box.just = "top", 
        legend.box.margin = margin())

# Get legend
plot_legend <- cowplot::get_legend(plot_2)

# Assemble the plot. 
# I realize that the code is a bit ugly, but the outcome seems acceptable
plot_grid(
  NULL, plot_legend, NULL, 
  double_plots[[1]], double_plots[[4]], double_plots[[6]], 
  NULL, NULL, NULL, 
  double_plots[[2]], double_plots[[3]], double_plots[[5]], 
  NULL, NULL, NULL, 
  double_plots[[9]], double_plots[[10]],double_plots[[11]], 
  NULL, NULL, NULL, 
  double_plots[[7]], double_plots[[8]], double_plots[[12]],
  labels = c(
    "", "", "",
    "A) RT learning indices", "", "",
    "", "", "",
    "B) ACC learning indices", "", "", 
    "", "", "",
    "C) General skill indices", "", "D) WM and EF indices",
    "", "", "",
    "", "", ""),
  hjust = -.05,
  vjust = .05,
  nrow = 8,
  rel_heights = c(.20, 1, .15, 1, .15, 1, .15, 1)
) + 
  geom_segment(y = .74, yend = .74, x = .02, xend = .98, size = 1.1) +
  geom_segment(y = .49, yend = .49, x = .02, xend = .98, size = 1.1) +
  geom_segment(y = .02, yend = .49, x = .668, xend = .668, size = 1.1) +
  NULL

```



# References